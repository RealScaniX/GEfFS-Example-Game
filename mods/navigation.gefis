This is navigation by ScaniX

entity Place is a Thing
	its actions are {"look at $"}
   attributes
      bool known
      list persons
      list items
      map exits   // either a place or a door
		text intro	// text to be said when first entering a place
		number illumination // is there a light in this place?
		bool navigatable is true // if false we are somewhere that cannot be entered/left by normal means
		text ambience    // name of audio track for ambience
		text music		// name of audio track for music

when play resumes
	stop audio channel "sound"
	if globals.ambiencetrack is null
		stop audio channel "ambience"
	else
		loop globals.ambiencetrack on audio channel "ambience"
	if globals.musictrack is null
		stop audio channel "music"
	else
		loop globals.musictrack on audio channel "music"

entity Passage is a Thing
	its description is @[passagedesc]
	its actions are {"look at $", "go $"}
	attributes
		text preproc		// the name of a function to call before trying to use this passage
		place origin
		place destination
		bool passable is true

function passagedesc
	do
		if player.location is this.destination and this.origin.known
			return "This leads to the " + this.origin + "."
		else if player.location is this.origin and this.destination.known
			return "This leads to the " + this.destination + "."

entity Door is a Passage
	its preproc is "doortrip"
	its passable is @this.open
	its actions are {"look at $", "open $", "close $"}
	its description is @[doordesc]
   attributes
      bool locked
      bool open
      key key

function doordesc
	do
		append "The door looks pretty normal for [a|an][if this.open]open[else]closed[end] door.[if this.open][+passagedesc][end]\n"
		if this.locked
			play "doorLocked.mp3" on audio channel "sound" with volume 100
			append "A push on the door handle reveals that this door is locked."

function doortrip
	do
		if this.locked
			say "The [+this.name] is locked."
			play "doorLocked.mp3" on audio channel "sound" with volume 100
			return false
		else if not this.open
			setDoor this, true
		return true

action unlock
	understand
		unlock [d]
	do
		say "What will you use to unlock it with?"
		ask "Key?"
		if user.canceled or user.input is empty
			return
		now k is [resolveitem user.input]
		invoke action "unlockwithkey"

action unlockwithkey
	understand
		unlock [d] with [k]
		unlock the [d] with the [k]
		unlock [d] with a [k]
		unlock the [d] with a [k]
	do
		now d is [resolveitem d]
		now k is [resolveitem k]
		if d is null
			say "You don't see that here."
			return
		if k is null
			say "You don't see that here."
			return
		if not (k is a key)
			say "You cannot open anything using [a|an][+k.name]."
			return
		if not (player.inventory has k)
			say "[one of]Wishful thinking will not let that key materialzie in your hand. Or will it?[or]Sticking your hand into your pocket you regretfully realize that you don't have this key.[at random]"
			return
		if d is a door or d is a container
			if d.key is k
				now d.locked is false
				say "You successfully unlock the [+d.name] using the [+k.name]."
			else
				say "[one of]You try every possible angle, but that key will not open the [+d.name].[or]Sheer force will not make that key fit either. The [+d.name] stays locked.[at random]"

function setDoor
	understand
		setDoor [d], [state]
	do
		if not (d is a Door)
			say "You don't know how to open this."
			return
		if not (player.location.exits has d)
			say "You don't see this here."
			return
		if d.open is state
			if d.open
				say "Isn't it open enough for you?"
			else
				say "It already is closed. It might not be airtight, but there is nothing you can do about it."
			return
		if d.locked and state
			say "The [+d.name] is locked."
			play "doorLocked.mp3" on audio channel "sound" with volume 100
			return
		now d.open is state
		play "doorHandle.mp3" on audio channel "sound" with volume 100
		flush
		sleep 0.95
		if d.open
			play "doorOpen.mp3" on audio channel "sound" with volume 100
		else
			play "doorClose.mp3" on audio channel "sound" with volume 100
		flush
		sleep 0.5
		say "You [if state]open[else]close[end] the door."

entity Stairway is a Passage
	its preproc is "stairwaytrip"
	its passable is true
	its actions are {"look at", "go $"}

function stairwaytrip
	do
		if chance of (player.location.illumination + player.illumination) in 50
			// all fine
			return true
		otherwise
			// player tripped in the dark
			if player.location is this.origin
				// moving up
				say "You trip because of the dim light and hit your knee on the step. *ouch!*\n"
			else
				// moving down
				say "Halfway down you misplace your foot in the dark and were coming down faster than planned."
			// still managed to get to the destination though
			return true

entity Key is an item

action navigate
   understand
      go [destination]
   modes
      main
   do
      //say "You want to go " + destination.name + "."
		// can we navigate at all?
		if not player.location.navigatable
			say "[one of]You cannot leave this place.[or]There is no easy way out from here.[or]You see no exit.[at random]"
			return
		// find target
		if destination is a place and destination.known
			// look for passage to that place
			for each exit in player.location.exits
				if exit is destination
					goToPlace exit
					return
				else if exit is a passage and exit.destination is destination or exit.origin is destination
					followpassage exit
					return
		else if destination is a passage
			followpassage destination
			return
		else
         //say destination.name+" is not a place."
			// no place, but is that the name of a passage?
			if player.location.exits has destination.name
				//say "It is an exit."
				now exit is player.location.exits.(destination.name)
				if exit is a place
					say "The exit " + destination.name + " leads to the place " + exit + "."
					goToPlace exit
				else if exit is a passage
					followpassage exit
				return
		say "You don't know such a place nor a path leading to it."

function followpassage
	understand
		followpassage [p]
	do
		//say "The exit " + exit.name + " is a passage between "+exit.origin+" and "+exit.destination+"."
		if not (p.preproc is null)
			invoke function p.preproc on p
		if p.passable
			if player.location is p.origin
				//say "Following the passage forward."
				goToPlace p.destination
			else if player.location is p.destination
				//say "Following the passage backwards."
				goToPlace p.origin
			else
				say "We seem to have run into an error..."


function goToPlace
	understand
		goToPlace [destination]
	do
		if not destination is a place
			say "The destination is no place! :(\n"
			return
		now player.location is destination
		if not player.location.known
			now player.location.known is true
			say player.location.intro
		updateaudio

function updateaudio
	do
		if not (globals.ambiencetrack is player.location.ambience)
			if player.location.ambience is null
				stop audio channel "ambience"
			else
				loop player.location.ambience on audio channel "ambience"
			now globals.ambiencetrack is player.location.ambience
		if not (globals.musictrack is player.location.music)
			if player.location.music is null
				stop audio channel "music"
			else
				loop player.location.music on audio channel "music"
			now globals.musictrack is player.location.music

action lookaround
	understand
		look around
	do
		say player.location.description

// navigation shortcuts
action navshortcuts
	understand
		up
		down
		north
		south
		east
		west
	do
		do "go [+user.input]"
